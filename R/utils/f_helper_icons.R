# Merged icons helper file
# This file consolidates functions from utils/f_helper_icons.R, utils/helper_icons.R, and utils/icons.R.
# - Functions detected as USED in the app remain active.
# - Functions not detected as used are preserved but commented out under an UNUSED section.
# After verifying, you can rename this file to utils/f_helper_icons.R and remove the others.
#
# Generated by script on merge.

# === USED FUNCTIONS ===

# Source: Silo/R/utils/icons.R

bottom_type_icons <- function() {
  c(
    HOPPER = "ðŸ”»",
    FLAT   = "â–­"
  )
}

# Source: Silo/R/utils/helper_icons.R
build_payload <- function(icon_name, svg_txt, color_hex = NULL) {
  if (!nzchar(svg_txt)) stop("Empty SVG")
  
  # Only generate one PNG size for thumbnails
  png32 <- raw_to_b64(svg_to_png_raw(svg_txt, size = 32))
  
  list(
    icon_name = icon_name,
    svg = svg_txt,
    png_32_b64 = png32,
    primary_color = color_hex  
  )
}

# Source: Silo/R/utils/icons.R

container_type_icons <- function() {
  c(
    # Shape-bottom semantics (more intuitive)
    HOPPER   = "ðŸ”»",  # down-pointing funnel/triangle
    FLAT     = "â–­",  # flat rectangle/plate
    
    # Common/legacy (kept)
    BIN      = "ðŸ§±",
    TANK     = "â­•",
    MIXER    = "ðŸŒ€",
    
    # Your requested types
    SILO     = "ðŸ—ï¸", # storage silo
    HOLDING  = "ðŸ“¦",  # holding/bin
    DRYING   = "ðŸ”¥",  # drying bin
    BULKTANK = "ðŸ›¢ï¸", # external bulk tank
    NEWCODE  = "ðŸ§©"   # placeholder/new
  )
}

# Source: Silo/R/utils/helper_icons.R
fetch_iconify_svg <- function(id_or_prefix, name = NULL) {
  if (!is.null(name)) {
    prefix <- id_or_prefix
    icon   <- name
  } else {
    parts <- strsplit(id_or_prefix, ":", fixed = TRUE)[[1]]
    if (length(parts) != 2) return("")
    prefix <- parts[1]; icon <- parts[2]
  }
  url <- sprintf("%s/%s/%s.svg", ICONIFY_BASE, prefix, icon)
  txt <- try(paste(readLines(url, warn = FALSE), collapse = "\n"), silent = TRUE)
  if (inherits(txt, "try-error")) "" else txt
}

# Source: Silo/R/utils/icons.R

icon_for_container <- function(type_code = NULL, bottom_type = NULL, type_name = NULL) {
  ct <- container_type_icons()
  bt <- bottom_type_icons()
  
  if (!is.null(type_code) && nzchar(type_code)) {
    key <- toupper(type_code)
    if (!is.na(ct[[key]])) return(ct[[key]])
  }
  
  nm <- if (!is.null(type_name) && nzchar(type_name)) toupper(type_name) else ""
  if (nzchar(nm)) {
    if (grepl("SILO", nm, fixed = TRUE))        return(ct[["SILO"]])
    if (grepl("HOLD", nm, fixed = TRUE))        return(ct[["HOLDING"]])
    if (grepl("DRY", nm,  fixed = TRUE))        return(ct[["DRYING"]])
    if (grepl("BULK", nm, fixed = TRUE) ||
        grepl("TANK", nm, fixed = TRUE))        return(ct[["BULKTANK"]])
  }
  
  if (!is.null(bottom_type) && nzchar(bottom_type)) {
    key <- toupper(bottom_type)
    if (!is.na(bt[[key]])) return(bt[[key]])
    if (!is.na(ct[[key]])) return(ct[[key]])
  }
  
  "â—»ï¸"
}

# Source: Silo/R/utils/helper_icons.R
iconify_search_all <- function(query, limit = 24, page_size = 200, max_results = 5000) {
  if (is.null(query) || !nzchar(query)) return(character(0))
  limit <- as.integer(limit)
  page_size <- as.integer(page_size)
  max_results <- as.integer(max_results)
  
  out <- character(0)
  start <- 0
  want <- min(limit, max_results)
  
  repeat {
    chunk_limit <- min(page_size, want - length(out))
    if (chunk_limit <= 0) break
    ids <- iconify_search_page(query = query, start = start, limit = chunk_limit)
    if (!length(ids)) break
    out <- unique(c(out, ids))
    start <- start + length(ids)
    if (length(ids) < chunk_limit || length(out) >= want) break
  }
  
  utils::head(out, want)
}

# Source: Silo/R/utils/helper_icons.R
iconify_search_page <- function(query, start = 0, limit = 200) {
  resp <- try(httr::GET(
    sprintf("%s/search", ICONIFY_BASE),
    query = list(query = query, start = start, limit = limit)
  ), silent = TRUE)
  if (inherits(resp, "try-error") || httr::http_error(resp)) return(character(0))
  txt <- httr::content(resp, "text", encoding = "UTF-8")
  if (!is.character(txt) || !nzchar(txt)) return(character(0))
  j <- try(jsonlite::fromJSON(txt), silent = TRUE)
  if (inherits(j, "try-error") || is.null(j$icons)) return(character(0))
  
  # j$icons can be a character vector or a list; coerce both safely
  if (is.character(j$icons)) return(j$icons)
  as.character(unlist(j$icons, use.names = FALSE))
}

# Source: Silo/R/utils/helper_icons.R
raw_to_b64 <- function(xraw) {
  if (is.null(xraw)) return("")
  base64enc::base64encode(xraw)
}

# Source: Silo/R/utils/helper_icons.R
recolor_svg <- function(svg_txt, color_hex) {
  if (is.null(svg_txt) || !nzchar(svg_txt)) return("")
  if (is.null(color_hex) || !nzchar(color_hex)) return(svg_txt)

  # Try XML-based recoloring for better precision
  doc <- try(xml2::read_xml(svg_txt, options = c("NOBLANKS", "RECOVER")), silent = TRUE)
  if (inherits(doc, "try-error")) {
    # Fallback to regex if XML parsing fails
    x <- svg_txt
    x <- gsub("currentColor", color_hex, x, fixed = TRUE)
    x <- gsub('stroke="#?[0-9a-fA-F]{3,8}"', paste0('stroke="', color_hex, '"'), x)
    x <- gsub('fill="(?!none)#[^"]+"', paste0('fill="', color_hex, '"'), x, perl = TRUE)
    return(x)
  }

  # Find all nodes EXCEPT those inside <defs> or <mask>
  # We'll recolor elements that are in the main SVG body, not in definitions
  all_nodes <- xml2::xml_find_all(doc, "//*[not(ancestor-or-self::defs) and not(ancestor-or-self::mask)]")

  for (node in all_nodes) {
    # Replace currentColor in fill
    fill_val <- xml2::xml_attr(node, "fill")
    if (!is.na(fill_val) && fill_val == "currentColor") {
      xml2::xml_attr(node, "fill") <- color_hex
    }
    # Replace hex colors in fill (but not 'none')
    if (!is.na(fill_val) && fill_val != "none" && grepl("^#[0-9a-fA-F]{3,8}$", fill_val)) {
      xml2::xml_attr(node, "fill") <- color_hex
    }

    # Replace currentColor in stroke
    stroke_val <- xml2::xml_attr(node, "stroke")
    if (!is.na(stroke_val) && stroke_val == "currentColor") {
      xml2::xml_attr(node, "stroke") <- color_hex
    }
    # Replace hex colors in stroke
    if (!is.na(stroke_val) && grepl("^#[0-9a-fA-F]{3,8}$", stroke_val)) {
      xml2::xml_attr(node, "stroke") <- color_hex
    }
  }

  as.character(doc)
}

# Source: Silo/R/utils/helper_icons.R
sanitize_svg <- function(svg_txt) {
  if (is.null(svg_txt) || !nzchar(svg_txt)) return("")
  # Parse leniently; avoid HTML entity issues
  doc <- try(xml2::read_xml(svg_txt, options = c("NOBLANKS", "RECOVER")), silent = TRUE)
  if (inherits(doc, "try-error")) return("")
  
  # Remove script nodes
  scripts <- xml2::xml_find_all(doc, ".//script")
  xml2::xml_remove(scripts)
  
  # Strip on* event attributes everywhere
  nodes <- xml2::xml_find_all(doc, "//*")
  for (n in nodes) {
    attrs <- xml2::xml_attrs(n)
    if (length(attrs)) {
      # remove width/height at root and any on* attributes
      drop <- names(attrs)[grepl("^on", names(attrs), ignore.case = TRUE) | names(attrs) %in% c("width", "height")]
      for (a in drop) xml2::xml_attr(n, a) <- NULL
    }
  }
  # Ensure svg root has viewBox (if missing, try to infer)
  root <- xml2::xml_find_first(doc, ".")
  if (xml2::xml_name(root) == "svg") {
    vb <- xml2::xml_attr(root, "viewBox")
    if (is.na(vb) || !nzchar(vb)) {
      # Best effort: if width/height were present in original, theyâ€™re already removed.
      # We keep as-is; many Iconify SVGs already include viewBox.
      # (Optional: parse path bbox to compute viewBox â€“ omitted for speed.)
    }
  }
  
  as.character(doc)
}

# Source: Silo/R/utils/helper_icons.R
svg_to_png_raw <- function(svg_txt, size = 64) {
  if (is.null(svg_txt) || !nzchar(svg_txt)) stop("Empty SVG")
  if (!requireNamespace("magick", quietly = TRUE) && !requireNamespace("rsvg", quietly = TRUE)) {
    stop("Need magick or rsvg installed to rasterize SVG")
  }
  if (requireNamespace("magick", quietly = TRUE)) {
    img <- magick::image_read_svg(svg_txt, width = size, height = size)
    return(magick::image_write(img, format = "PNG"))
  } else {
    tmp <- tempfile(fileext = ".svg")
    on.exit(unlink(tmp), add = TRUE)
    writeLines(svg_txt, tmp, useBytes = TRUE)
    return(rsvg::rsvg_png(tmp, width = size, height = size))
  }
}


# === UNUSED / REDUNDANT (commented) ===

# # Source: Silo/R/utils/f_helper_icons.R
# f_fetch_iconify_svg <- function(id_or_prefix, name = NULL) {
#   fetch_iconify_svg(id_or_prefix, name)
# }

# # Source: Silo/R/utils/f_helper_icons.R
# f_iconify_search_all <- function(query, limit = 24, page_size = 200, max_results = 5000) {
#   # if your legacy helper already supports (query, limit), just delegate:
#   iconify_search_all(query, limit = limit)
# }

# # Source: Silo/R/utils/f_helper_icons.R
# f_sanitize_svg   <- function(svg_txt)                  sanitize_svg(svg_txt)
# f_recolor_svg    <- function(svg_txt, color_hex)       recolor_svg(svg_txt, color_hex)
# f_svg_to_png_raw <- function(svg_txt, size = 64)       svg_to_png_raw(svg_txt, size)
# 
# # Build DB payload
# f_build_payload  <- function(icon_name, svg_txt, primary_color = NULL)       build_payload(icon_name, svg_txt, color_hex = primary_color)
# 
# # f_icons_bind_search_upload() â€” wire ENTER search, magnifier click, and upload trigger
# # ns: the module NS() function (pass `ns` from inside your UI)
# f_icons_bind_search_upload <- function(ns) {
#   rid  <- ns("root")
#   qid  <- ns("q_prompt")
#   sid  <- ns("sem_search")
#   bid  <- ns("btn_pick_svg")
#   fid  <- ns("svg_upload_search")
#   cid  <- ns("color_hex")   # <- new
#   
#   tags$script(HTML(paste0(
#     "(function(rid,qid,sid,bid,fid,cid){",
#     "  var root = document.getElementById(rid); if(!root) return;",
#     "  var prompt = document.getElementById(qid);",
#     "  function doSearch(){",
#     "    if(!window.Shiny) return;",
#     "    var val = (prompt && prompt.value) ? prompt.value : '';",
#     "    Shiny.setInputValue(qid + '_val', val, {priority:'event'});",
#     "    Shiny.setInputValue(qid + '_enter', Date.now(), {priority:'event'});",
#     "  }",
#     "  if(prompt){",
#     "    prompt.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ ev.preventDefault(); doSearch(); } });",
#     "  }",
#     "  var sem = document.getElementById(sid);",
#     "  if(sem){",
#     "    sem.addEventListener('click', function(ev){",
#     "      var ico = ev.target.closest('.ui.icon.input .search.icon');",
#     "      if(ico){ ev.preventDefault(); doSearch(); }",
#     "    });",
#     "  }",
#     "  var pickBtn = document.getElementById(bid);",
#     "  var fileEl  = document.getElementById(fid);",
#     "  if(pickBtn && fileEl){ pickBtn.addEventListener('click', function(){ fileEl.click(); }); }",
#     "  // bind color input (native <input type=color>) -> input$color_hex",
#     "  var col = document.getElementById(cid);",
#     "  if(col){",
#     "    var push = function(){ if(window.Shiny) Shiny.setInputValue(cid, col.value, {priority:'event'}); };",
#     "    col.addEventListener('input', push);",
#     "    col.addEventListener('change', push);",
#     "  }",
#     "})('", rid, "','", qid, "','", sid, "','", bid, "','", fid, "','", cid, "');"
#   )))
# }

# # Source: Silo/R/utils/icons.R
# 
# icon_enum_options_for <- function(values, labels = NULL) {
#   if (is.null(labels)) labels <- as.character(values)
#   stopifnot(length(values) == length(labels))
#   mapply(function(v, lab) {
#     list(
#       value = v,
#       label = sprintf("%s  %s", icon_for_container(type_code = v, type_name = lab), lab)
#     )
#   }, values, labels, SIMPLIFY = FALSE, USE.NAMES = FALSE)
# }

